# Ch4 함수

- 값 넘겨주고 넘겨받기
- 값으로 취급되는 함수
- 메서드
- 활용



  코드의 덩어리를 만든 다음에 그를 호출하고 귀환할 수 있는 구조를 **서브루틴**이라고 부른다. 큰 프로그램을 서브루틴으로 구분하면 코드를 재사용하여 중복된 코드를 줄일 수 있고, 서브 루틴의 내부와 외부를 분리하여 생각할 수 있어서 코드를 추상화하고 단순화할 수 있다.

  Go에서는 이러한 서브루틴을 **함수**라고 부른다.  Go 언어는 값에 의한 호출 (Call by value)만을 지원한다. 함수 내에서 넘겨받은 변수값을 변경하더라도 함수 밖의 변수에는 영향을 주지 않는다. 변수에 담겨 있던 값만 넘어오게된다. 따라서, 함수 밖의 변수의 값을 변경하려면 해당 값이 들어 있는 주소값을 넘겨받아서 그 주소에 있는 값을 변경하여 참조에 의한 호출 (Call by reference)과 비슷한 효과를 낼 수 있다.



## 4.1 값 넘겨주고 넘겨받기

  서브루틴을 호출할 때, 그 서브루틴에 값을 넘겨주거나 받을 수 있다. 이를 통해, 서브루틴을 다른 값에 대하여 재사용할 수 있고, 결과값을 받아서 이용할 수 있다.



### 4.1.1 값 넘겨주기

  3장의 **텍스트 리스트 읽고 쓰기**에서, ReadFrom 함수에서 *[]string 자료형으로 lines를 받았다. 

```go
func ReadFrom(r io.Reader, lines *[]string) error {}
```

- []string 자료형이 아닌 *[]string 자료형으로 받은 이유는 이 ReadFrom 함수가 lines 변수의 값을 변경하고자 하기 때문
- 슬라이스는 배열에 대한 포인터, 길이 그리고 용량 이렇게 세 값으로 이루어짐
  - 만약, *[]string을 쓰지 않고 []string을 이용하여 넘겼다면 이 포인터, 길이, 용량 이렇게 세 개의 값이 넘어가며, 세 개의 값을 담고 있던 변수와는 연관성이 없어짐
  - 즉, lines []string 과 같이 받았다면, 함수 내의 lines 변수가 품고 있는 세 값을 변경해도 원래 변수의 변경과는 무관하다.

```go
func AddOne(nums []int) {
    for i := range nums {
        nums[i]++
    }
}

func ExampleAddOne() {
    n := []int{1,2,3,4}
    AddOne(n)
    fmt.Println(n)
    
    // Output :
    // [2 3 4 5]
}
```

- AddOne 함수에 값을 넘겨주었는데, 값을 넘겨주었는데도 호출 뒤에 n에 대해 변경이 일어남
- Go에서의 슬라이스가 배열에 대한 포인터, 길이, 용량 이렇게 세 값으로 이루어진 것으로 이 세 값이 넘어간 것이기 때문
  - 정수 1,2,3,4가 넘어간 것이 아님



```go
func ReadFrom(r io.Reader, lines *[]string) error { }
```

- 위의 함수가 *[]string과 같은 포인터를 넘겨주는 이유?
  - 함수가 넘겨준 슬라이스의 값을 변경해야 하기 때문
  - 슬라이스 값?
    - 배열 포인터
    - 길이
    - 용량
  - 포인터로 넘어온 값은 *을 앞에 붙여 값을 참조할 수 있음
  - 변수 앞에 &을 붙이면 해당 변수에 담겨 있는 포인터 값을 얻을 수 있음



### 4.1.2 둘 이상의 반환값

  Go 언어의 함수에서는 **둘 이상의 반환값**을 둘 수 있음

```go
func WriteTo(w io.Writer, lines []string) error { }
```

- 원래는 에러값 하나를 반환하는 함수



- 실제로 몇 바이트를 썼는지 알고 싶은 경우에는?

  - 기존의 C 언어에서는, 바이트 수를 반환하는 함수 하나를 더 작성해야 했음

  ```go
  func WriteTo(w io.Writer, lines []string) (int64, error) { }
  ```

  - return 값을 두 개로 둘 수 있음

  - return 값이 두 개 이상인 경우 

    - **괄호**로 둘러싸서 반환값을 구분해야 함

      

  - 함수 안에서 값을 반환할 때?
    - 쉼표로 구분하여 return

  ```go
  func WriteTo(w io.Writer, lines []string) (int64, error) {
  	...
      return n, err //  쉼표로 구분하여 반환
  }
  ```

  

  - 값을 받을 때?
    - 쉼표로 구분하여 return 값의 수에 맞게 받음

  ```
  _, err := WriteTo(w, lines)
  ```



### 4.1.3 에러 값 주고받기

- 둘 이상의 값을 리턴할 수 있게 되면서 return 값을 이용한 에러 처리가 조금 더 수월해짐

- 기존에는, 에러값을 주고 받기 위해 

  - 정상적이지 않은 경우에, 음수를 반환하여 에러를 의미하도록 규정
  - 호출하는 쪽에서 에러값을 받고 싶은 변수의 포인터나 레퍼런스를 함수로 넘겨 주어 받는 방법

  

- 첫번째, 음수를 반환하여 에러를 의미하는 경우 

  - Go 에서는, 에러가 아닌 정상적인 경우에 이를 활용
    - ex) strings.Index*는 문자열에서 원하는 문자열이 나타나는 위치를 돌려주는 함수
    - 인덱스는 0부터 시작하므로, 음수가 나올 수 없는 상황
    - 따라서, 문자열이 발견되지 않으면 -1을 return
    - 해당 경우는 에러 상황은 아니고, 정상적인 상황의 한 종류일 뿐



- Go 에서는 **에러**는 **가장 마지막 값**으로 반환

- 새로운 에러를 생성해야 하는 경우

  - errors.New 나 fmt.Errorf 이용

    ```go
    return errors.New("stringlist.ReadFrom: line is too long")
    ```

    ```go
    return fmt.Errorf("stringlist: too long line at %d", count) // fmt.Errorf로 부가 정보를 추가한 메시지를 리턴
    ```



### 4.1.4  명명된 결과 인자

  위의 함수 예시들은 넘겨받는 인자에는 이름이 있었지만, 돌려주는 값에는 이름 없이 자료형만 나열하였음

- Go에서는 반환하는 값들 역시 이름을 붙여 사용 가능

  - 넘겨받는 인자들 (파라미터)은 넘어온 값들로 초기값이 설정됨
  - 돌려주는 인자들(리턴값)은 기본값으로 초기화됨 (정수면 0, 문자열이라면 빈 문자열로 초기값 설정)

  

- 반환 시, 기존의 방식대로 결과값들을 return 뒤에 쉼표로 구분하여 나열할 수도 있고, 생략하고 return만 쓸 수도 있음

- 생략한 경우에는 돌려주는 인자들의 값들이 반환됨

```go
func WriteTo(w io.Writer, lines []string) (n int64, err error) {
    for _, line := range lines {
        var nw int
        nw, err = fmt.Fprintln(w, line)
        n += int64(nw)
        
        if err != nil {
            return
        }
    }
    
    return
}
```

- 위의 예제는 명명된 결과 인자 (Named return parameter)를 사용해도 눈에 띄게 좋은 것은 없음



### 4.1.5 가변 인자

- 넘겨받을 수 있는 인자의 개수가 정해져 있지 않은 함수?

  ```go
  func f(w io.Writer, nums []int) {
      ...
  }
  
  func main() {
      ...
      f(w, []int{x,y,z}) // Go는 값을 넘기므로, 그 값을 슬라이스에 담아서 넘기기
  }
  ```

  

- 슬라이스로 갖고있는 자료를 가변인자를 두고 있는 함수로 넘기는 경우?

  ```go
  lines := []string{"hello", "world", "Go language"}
  WriteTo(w, lines...)
  ```

  

## 4.2 







